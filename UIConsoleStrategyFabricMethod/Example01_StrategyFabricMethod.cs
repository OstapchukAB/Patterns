using System;
using System.IO;
using System.Linq;

#region Описание
/*
пример процедурного (антипаттерн) кода для обработки файлов. 
В этом примере метод ProcessFile выполняет все действия – определяет тип файла по расширению,
выбирает алгоритм обработки и выполняет его, используя цепочку условных операторов.
Такой подход затрудняет расширение, тестирование и сопровождение кода.
Его можно использовать как отправную точку для последующего рефакторинга с применением паттернов Фабрика и Стратегия.
*****************************
Ключевые моменты данного антипаттерна:

Объединение логики создания и применения алгоритмов:
Метод ProcessFile сам определяет, какую обработку выполнить, что нарушает принцип единственной ответственности.

Жёсткое связывание с типами файлов:
При добавлении нового формата (например, XML или HTML) нужно изменять этот метод, что нарушает принцип открытости/закрытости (OCP).

Отсутствие инкапсуляции алгоритмов:
Логика обработки каждого типа файла распределена внутри одного метода, что затрудняет повторное использование и тестирование отдельных алгоритмов.

Этот код можно использовать как отправную точку для рефакторинга с применением паттернов Фабрика (для создания обработчиков файлов)
и 
Стратегия (для инкапсуляции алгоритмов обработки), что позволит добиться более гибкого и расширяемого решения.

*/ 
#endregion
namespace FileProcessingAntiPattern
{
    class Program
    {
        /// <summary>
        /// Процедурный метод для обработки файла.
        /// Определяет тип файла по расширению и выполняет соответствующую логику:
        /// - .txt: считает количество строк
        /// - .csv: считает количество столбцов в первой строке
        /// - .json: приближённо считает количество объектов (на основе подсчёта символов '{')
        /// При добавлении нового типа файла потребуется модификация этого метода.
        /// </summary>
        /// <param name="filePath">Путь к файлу</param>
        public static void ProcessFile(string filePath)
        {
            if (!File.Exists(filePath))
            {
                Console.WriteLine("Файл не существует.");
                return;
            }

            // Получаем расширение файла в нижнем регистре.
            string extension = Path.GetExtension(filePath).ToLower();

            if (extension == ".txt")
            {
                // Обработка текстового файла: подсчёт количества строк.
                string[] lines = File.ReadAllLines(filePath);
                Console.WriteLine("Текстовый файл содержит {0} строк.", lines.Length);
            }
            else if (extension == ".csv")
            {
                // Обработка CSV-файла: подсчёт количества столбцов в первой строке.
                string[] lines = File.ReadAllLines(filePath);
                if (lines.Length > 0)
                {
                    string[] columns = lines[0].Split(',');
                    Console.WriteLine("CSV-файл содержит {0} столбцов.", columns.Length);
                }
                else
                {
                    Console.WriteLine("CSV-файл пуст.");
                }
            }
            else if (extension == ".json")
            {
                // Обработка JSON-файла: приближённый подсчёт объектов.
                // (Наивный способ – подсчитываем количество символов '{'.)
                string jsonContent = File.ReadAllText(filePath);
                int objectCount = jsonContent.Count(ch => ch == '{');
                Console.WriteLine("JSON-файл содержит приблизительно {0} объектов.", objectCount);
            }
            else
            {
                Console.WriteLine("Неподдерживаемый тип файла: {0}", extension);
            }
        }

        static void Main(string[] args)
        {
            Console.OutputEncoding = System.Text.Encoding.UTF8;
            Console.WriteLine("Введите путь к файлу:");
            string filePath = Console.ReadLine();

            // Вызываем процедурный метод для обработки файла.
            ProcessFile(filePath);
        }
    }
}
